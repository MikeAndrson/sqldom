<!DOCTYPE html>
<html lang="en">
<head>
    <title>node-sql-parser</title>
    <meta charset="utf-8"/>
    <style>
        * {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #f5f5f5;
        }

        .container {
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #sql-form {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #sql-input {
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            font-size: 16px;
            outline: none;
            margin-top: 10px;
        }

        .flashing {
            animation: flashing .5s infinite;
            border: red 1px solid !important;
        }

        @keyframes flashing {
            0% {
                background-color: #fff;
            }
            50% {
                background-color: #fdd46f;
            }
            100% {
                background-color: #fff;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <form id="sql-form" autocomplete="off">
        <label for="sql-input">Query DOM elements using SQL</label>
        <input type="text" id="sql-input" style="width: 500px; height: 150px;"
               value="select * from dom where type='text' or id='sql-form' ">
    </form>
</div>
<script src="https://unpkg.com/node-sql-parser/umd/mysql.umd.js"></script>
<script>
    const getSqlParser = () => {
        return window.sqlParser ||= new NodeSQLParser.Parser();
    }

    const sqlInput = document.getElementById('sql-input');
    const sqlForm = document.getElementById('sql-form');

    sqlForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const sql = sqlInput.value;
        const {ast} = getSqlParser().parse(sql);

        if (Array.isArray(ast)) {
            ast.forEach(evalSql);
        } else {
            evalSql(ast);
        }
    });

    function buildCssSelector(ast) {
        let tables;
        if (ast.type === 'select') {
            tables = ast.from;
        } else if (ast.type === 'update' || ast.type === 'delete') {
            tables = ast.table;
        } else {
            throw new Error('Unsupported query type: ' + ast.type);
        }

        // If any of the tables is "dom", select all elements
        return tables.some(t => /dom/i.test(t.table))
            ? '*'
            : tables.map(t => t.table).join(',');
    }

    function evalSql(ast) {
        const {type, where, set} = ast;
        const selector = buildCssSelector(ast);

        const elements = [...document.querySelectorAll(selector)]
            .filter(element => where ? evalWhere(element, where) : true);

        console.log(elements);
        elements.forEach(element => element.classList.add('flashing'));
        setTimeout(() => elements.forEach(element => element.classList.remove('flashing')), 1500);

        if (type === 'select') {
            // nothing
        } else if (type === 'update') {
            elements.forEach(element => {
                set.forEach(({column, value}) => {
                    element.setAttribute(column, evalOperand(element, value));
                });
            });
        } else if (type === 'delete') {
            elements.forEach(element => element.remove());
        }
    }

    function evalOperand(element, operand) {
        const refTypes = ['column_ref'];
        const valueTypes = ['single_quote_string', 'string', 'number', 'bool', 'null'];

        if (refTypes.includes(operand.type)) {
            return element.getAttribute(operand.column);
        } else if (valueTypes.includes(operand.type)) {
            return operand.value;
        } else if (operand.type === 'function') {
            return evalFunction(element, operand);
        }

        throw new Error('Unsupported operand: ' + JSON.stringify(operand));
    }

    function evalFunction(element, operand) {
        const args = operand.args.value;

        const _evalOperand = (operand) => evalOperand(element, operand);

        switch (operand.name.toLowerCase()) {
            case 'length':
                return _evalOperand(args[0])?.toString().length ?? 0;
            case 'concat':
                return args.map(_evalOperand).join('');
            case 'concat_ws':
                const params = args.map(_evalOperand);
                return params.slice(1).join(params[0]);
        }

        throw new Error('Unsupported function: ' + JSON.stringify(operand));
    }

    function evalWhere(element, where) {
        const {left, right, operator, expr} = where;

        const _evalOperand = (operand) => evalOperand(element, operand);

        switch (operator) {
            case 'NOT':
                return !evalWhere(element, expr);
            case 'OR':
                return evalWhere(element, left) || evalWhere(element, right);
            case 'AND':
                return evalWhere(element, left) && evalWhere(element, right);
            case '=':
                return _evalOperand(left) === _evalOperand(right);
            case '!=':
            case '<>':
                return _evalOperand(left) !== _evalOperand(right);
            case 'IS':
                return _evalOperand(left) === _evalOperand(right);
            case 'IS NOT':
                return _evalOperand(left) !== _evalOperand(right);
            case '<':
                return _evalOperand(left) < _evalOperand(right);
            case '<=':
                return _evalOperand(left) <= _evalOperand(right);
            case '>':
                return _evalOperand(left) > _evalOperand(right);
            case '>=':
                return _evalOperand(left) >= _evalOperand(right);
            case 'LIKE':
            case 'NOT LIKE': {
                const lhs = _evalOperand(left);
                const rhs = _evalOperand(right);
                const likeToRegex = (like) =>
                    new RegExp('^' + like.replace(/%/g, '.*').replace(/_/g, '.') + '$');

                const result = likeToRegex(rhs).test(lhs);
                const negate = operator.startsWith('NOT');

                return negate ? !result : result;
            }
            case 'RLIKE':
            case 'NOT RLIKE': {
                const lhs = _evalOperand(left);
                const rhs = _evalOperand(right);

                const result = new RegExp(rhs).test(lhs);
                const negate = operator.startsWith('NOT');

                return negate ? !result : result;
            }
            case 'IN':
            case 'NOT IN':
            case 'BETWEEN':
            case 'NOT BETWEEN': {
                if (left.type === 'expr_list') {
                    throw new Error(`Left hand side cannot be a list in an ${operator} condition`);
                }
                if (right.type !== 'expr_list') {
                    throw new Error(`Right hand side has to be a list in an ${operator} condition`);
                }

                const lhs = _evalOperand(left);
                const rhs = right.value.map(_evalOperand);
                const negate = operator.startsWith('NOT');

                if (operator === 'IN' || operator === 'NOT IN') {
                    const result = rhs.includes(lhs);
                    return negate ? !result : result;
                } else if (operator === 'BETWEEN' || operator === 'NOT BETWEEN') {
                    const result = lhs >= rhs[0] && lhs <= rhs[1];
                    return negate ? !result : result;
                } else {
                    throw new Error('Unsupported operator: ' + operator);
                }
            }
            case undefined:
                // select * from dom where 1
                return !!_evalOperand(where);
        }

        throw new Error('Unsupported operator: ' + operator);
    }
</script>
</body>
</html>

